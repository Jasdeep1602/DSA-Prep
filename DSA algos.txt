These algos help to identify and solve problems.

✅ Sliding Window and Two Pointer
✅ Greedy (Mostly Sorting)
✅ Binary Search on Answer
✅ All Combinations/Permutations/Ways
✅ K Smallest / K Largest → Heaps
✅ Prefix/Suffix/Word Search → Tries
✅ Graph - DFS / BFS
✅ Topological Sort
✅ Bitwise XOR
✅ Tree - DFS/BFS
✅ Slow and Fast Pointers - LinkedList
✅ Parenthesis Problems - Stack
✅ DP - Knapsack Problem


1.Greedy✅:

Easy:
"Best Time to Buy and Sell Stock" (LC #121)
"Meeting Rooms" (LC #252)

Medium:
"Jump Game" (LC #55) 
"Task Scheduler" (LC #621)
"Non-overlapping Intervals" (LC #435) 

Hard:
"Meeting Rooms III" (LC #2402) 
"Minimum Number of Taps to Open to Water a Garden" (LC #1326) 
"Maximum Performance of a Team" (LC #1383) 

Key patterns to recognize for greedy problems:

Interval scheduling (sort by start/end time)
Maximum/minimum path problems
Optimization with local choices
Problems involving sorting first

2.Sliding Window✅:

Easy:
"Contains Duplicate II" (LC #219)

Medium:
"Longest Substring Without Repeating Characters" (LC #3)
"Minimum Size Subarray Sum" (LC #209)
"Longest Repeating Character Replacement" (LC #424)

Hard:
"Minimum Window Substring" (LC #76) 

Key patterns to recognize:

Fixed-size window: Window size remains constant (like k elements)
Dynamic-size window: Window size varies based on conditions
Two pointers: Usually 'start' and 'end' to manage the window
Hash map/Counter: Often used to track frequencies within window
